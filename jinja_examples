### Если from_dttm и to_dttm не указаны, то фильтруем по всем датам до сегодняшнего дня
### Если используем фильтр time_column, то подставляются вместо шаблонов подставляются края диапазона

SELECT ca.courier_id, ca.order_id, ca.action, ca.time::date, c.sex, c.birth_date from courier_actions ca
join couriers c on ca.courier_id=c.courier_id
where 1=1
{% if from_dttm is not none %}
and ca.time>='{{from_dttm}}'
{% endif %}
{% if to_dttm is not none %}
and ca.time<='{{to_dttm}}'
{% endif %}


### Здесь мы сначала создаем в sql-лабе отдельный датасет с рангами, затем создаем фильтр на его основе и применяем его только, к тем графикам, к которым нужно.
### Подставляем через filter_values значение из этого фильтра, далее если хотим условие IN и накликивать несколько значений, то пишем так
SELECT 
    courier_id::text,
    "orders",
    rank() OVER (ORDER BY "orders" DESC) AS rnk,
    CASE
        WHEN rank() OVER (ORDER BY "orders" DESC) IN (
            {% set values = filter_values('num', remove_filter=True) %}
            {% if values %}
                {{ values | map('int') | join(', ') }}
            {% else %}
                1, 2, 3  -- по умолчанию ТОП-3
            {% endif %}
        )
        THEN courier_id::text
        ELSE 'Other'
    END AS couriers_id_TOP
FROM (
    SELECT 
        courier_id,
        COUNT(order_id) AS "orders"
    FROM courier_actions
    WHERE action = 'deliver_order'
    GROUP BY courier_id
) AS sql


### Если хотим одно значение всегда передавать, то обращаемся к первому и единственному элементу списка
SELECT courier_id::text,
          "orders",
          rank() OVER (
                       ORDER BY "orders" DESC) AS rnk,
                      CASE
                          WHEN rank() OVER (
                                            ORDER BY "orders" DESC) <= (('{{ filter_values('num',remove_filter=True,)[0] }}')) THEN courier_id::text
                          ELSE 'Other'
                      END AS couriers_id_TOP
   FROM
     (SELECT courier_id,
             COUNT(order_id) AS "orders"
      FROM courier_actions
      WHERE action = 'deliver_order'
      GROUP BY courier_id) AS sql


### Сначала создаем датасет-справочник со значениями "переменных", далее подставляем это поле в filter_values и взависимости от значения переменной применяем ту или иную агрегационную функцию.
select sex,
(case
when '{{filter_values('agg', remove_filter=True)[0]}}'='Max' then max(order_id)
when '{{filter_values('agg', remove_filter=True)[0]}}'='Min' then min(order_id)
when '{{filter_values('agg', remove_filter=True)[0]}}'='Avg' then avg(order_id)
when '{{filter_values('agg', remove_filter=True)[0]}}'='Sum' then sum(order_id)
else null end) as agregation from
(SELECT ca.courier_id, ca.order_id, ca.action, ca.time::date, c.sex, c.birth_date
from courier_actions ca
join couriers c on ca.courier_id=c.courier_id) as t
group by sex

### Предварительно вычислив какую-то метрику, можно через raw records добавить ее в плоскую таблицу и производить фильтрацию по данному столбцу, задав в настройках чарта данное выражение
"summa">={{ (filter_values('sum(order_id)')[0] if filter_values('sum(order_id)') else 0) | int}}

