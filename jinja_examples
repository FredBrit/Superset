### Если from_dttm и to_dttm не указаны, то фильтруем по всем датам до сегодняшнего дня
### Если используем фильтр time_column, то подставляются вместо шаблонов подставляются края диапазона

SELECT ca.courier_id, ca.order_id, ca.action, ca.time::date, c.sex, c.birth_date from courier_actions ca
join couriers c on ca.courier_id=c.courier_id
where 1=1
{% if from_dttm is not none %}
and ca.time>='{{from_dttm}}'
{% endif %}
{% if to_dttm is not none %}
and ca.time<='{{to_dttm}}'
{% endif %}


### Здесь мы сначала создаем в sql-лабе отдельный датасет с рангами, затем создаем фильтр на его основе и применяем его только, к тем графикам, к которым нужно.
### Подставляем через filter_values значение из этого фильтра, далее если хотим условие IN и накликивать несколько значений, то пишем так
SELECT 
    courier_id::text,
    "orders",
    rank() OVER (ORDER BY "orders" DESC) AS rnk,
    CASE
        WHEN rank() OVER (ORDER BY "orders" DESC) IN (
            {% set values = filter_values('num', remove_filter=True) %}
            {% if values %}
                {{ values | map('int') | join(', ') }}
            {% else %}
                1, 2, 3  -- по умолчанию ТОП-3
            {% endif %}
        )
        THEN courier_id::text
        ELSE 'Other'
    END AS couriers_id_TOP
FROM (
    SELECT 
        courier_id,
        COUNT(order_id) AS "orders"
    FROM courier_actions
    WHERE action = 'deliver_order'
    GROUP BY courier_id
) AS sql


### Если хотим одно значение всегда передавать, то обращаемся к первому и единственному элементу списка
SELECT courier_id::text,
          "orders",
          rank() OVER (
                       ORDER BY "orders" DESC) AS rnk,
                      CASE
                          WHEN rank() OVER (
                                            ORDER BY "orders" DESC) <= (('{{ filter_values('num',remove_filter=True,)[0] }}')) THEN courier_id::text
                          ELSE 'Other'
                      END AS couriers_id_TOP
   FROM
     (SELECT courier_id,
             COUNT(order_id) AS "orders"
      FROM courier_actions
      WHERE action = 'deliver_order'
      GROUP BY courier_id) AS sql


### Сначала создаем датасет-справочник со значениями "переменных", далее подставляем это поле в filter_values и взависимости от значения переменной применяем ту или иную агрегационную функцию.
select sex,
(case
when '{{filter_values('agg', remove_filter=True)[0]}}'='Max' then max(order_id)
when '{{filter_values('agg', remove_filter=True)[0]}}'='Min' then min(order_id)
when '{{filter_values('agg', remove_filter=True)[0]}}'='Avg' then avg(order_id)
when '{{filter_values('agg', remove_filter=True)[0]}}'='Sum' then sum(order_id)
else null end) as agregation from
(SELECT ca.courier_id, ca.order_id, ca.action, ca.time::date, c.sex, c.birth_date
from courier_actions ca
join couriers c on ca.courier_id=c.courier_id) as t
group by sex

### Предварительно вычислив какую-то метрику, можно через raw records добавить ее в плоскую таблицу и производить фильтрацию по данному столбцу, задав в настройках чарта данное выражение
"summa">={{ (filter_values('sum(order_id)')[0] if filter_values('sum(order_id)') else 0) | int}}


### Присваиваем переменной первое значение из списка group, и взависимости от значения в фильтре, подставляем в гроупбай либо name, либо product_id
{% set group_type = filter_values('group', remove_filter=True)[0] if filter_values('group', remove_filter=True) else 'name' %}

SELECT
    {% if group_type == 'name' %}
        name AS dimension
    {% elif group_type == 'product_id' %}
        product_id AS dimension
    {% else %}
        name AS dimension
    {% endif %},
    SUM(price) AS sum_price
FROM products
GROUP BY
    {% if group_type == 'name' %}
        name
    {% elif group_type == 'product_id' %}
        product_id
    {% else %}
        name
    {% endif %}
ORDER BY sum_price DESC


### Шаблон для вычисления метрик за текущий и такой же прошлогодний период в рамках одного виртуального датасета. Для корректной работы устанавливаются значения по умолчанию и проверка на пустое значение
{% set default_from = '2023-01-01' %}
{% set default_to = '2025-12-31' %}

{% set start_date = from_dttm if from_dttm else default_from %}
{% set end_date = to_dttm if to_dttm else default_to %}

SELECT
    SUM(revenue) FILTER (
        WHERE date >= '{{ start_date }}'::date
          AND date < ('{{ end_date }}'::date + INTERVAL '1 day')  -- включает end_date
    ) AS sum_price_current,

    SUM(revenue) FILTER (
        WHERE date >= ('{{ start_date }}'::date - INTERVAL '1 year')
          AND date < ('{{ end_date }}'::date + INTERVAL '1 day' - INTERVAL '1 year')  -- тот же период в прошлом году
    ) AS sum_price_last_year

FROM (
    SELECT
        gs.dt::date AS date,
        ROUND((random() * 10000)::numeric, 2) AS revenue
    FROM generate_series(
        '2023-01-01'::date,
        '2025-12-31'::date,
        '1 day'
    ) AS gs(dt)
) AS t

